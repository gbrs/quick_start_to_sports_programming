""""
КузнечиК
Перед клетчатой полоской длины n сидит кузнечик.
Каждая клетка является либо занятой, либо свободной.
Кузнечик умеет прыгать на 1, 2, … k клеток вперед.
Найдите количество различных путей, которыми он может добраться до последней клетки,
не заходя в занятые.
Входные данные
В первой строке записано два целых числа n, k (1 <= k <= n <= 5 * 10^5).
Во второй строке записана строка длины n, состоящая только из нулей и единиц.
Ноль обозначает свободную клетку, а единица - занятую.
Выходные данные
Выведите единственное число - количество способов добраться до последней клетки.
Поскольку это число может быть очень большим, выведите его по модулю 10^9 + 7.
"""

n, k = map(int, input().split())
# псевдоначало списка для расчета суммы путей по сумме k элементов списка
lst = [0] * k
lst[-1] = 1  # место перед полоской
sumk = 1  # количество возможных путей в следующую ячейку (сумма k предыдущих элементов списка)
for number in map(int, input()):
    if not number:  # добавляем количество путей в текущую ячейку, если пришел 0
        lst.append(sumk)
    else:  # если клетка занята (в ней 1), то из нее путей нет
        lst.append(0)
    # количество путей в следующую ячейку - сумма скользящего окна размером k (префиксная сумма такая),
    # добавив к ней текущую ячейку и удалив дальнюю
    sumk = (sumk - lst[-k - 1] + lst[-1]) % (10 ** 9 + 7)
print(lst[-1])

# если k большое, то мы одни и те же числа в сумме вычисляем много раз
# надо префиксные суммы делать.
# И там засада с делением по модулю может всплыть.
# Но это, видимо только для C, который округляет отрицательные числа "не математически"
